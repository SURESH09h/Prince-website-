<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Advanced Car Game</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    #hud {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: white;
      background: rgba(0,0,0,0.6);
      padding: 12px;
      border-radius: 8px;
      font-size: 16px;
    }
    #mission {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 12px;
      border-radius: 8px;
      font-weight: bold;
    }
    #instructions {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 6px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="mission">ðŸŽ¯ Mission: Reach all 3 checkpoints!</div>
  <div id="instructions">
    W/S: Accelerate/Reverse<br>
    A/D: Steer<br>
    Space: Handbrake
  </div>
  <div id="hud">Speed: <span id="speed">0</span> km/h</div>

  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
  <script>
    // ====== INIT ======
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 30, 100);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lighting
    const sun = new THREE.DirectionalLight(0xffffff, 0.9);
    sun.position.set(30, 50, 20);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    scene.add(sun, new THREE.AmbientLight(0xffffff, 0.3));

    // Skybox (simple gradient via background already set)

    // ====== PHYSICS WORLD ======
    const world = new CANNON.World({
      gravity: new CANNON.Vec3(0, -9.82, 0),
      broadphase: new CANNON.NaiveBroadphase()
    });

    // ====== TERRAIN & ENVIRONMENT ======
    // Ground
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x3d7c3d }); // Grass
    const groundMesh = new THREE.Mesh(groundGeo, groundMat);
    groundMesh.rotation.x = -Math.PI / 2;
    groundMesh.receiveShadow = true;
    scene.add(groundMesh);

    const groundBody = new CANNON.Body({ mass: 0 });
    groundBody.addShape(new CANNON.Plane());
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(groundBody);

    // Road (simple gray strip)
    const road = new THREE.Mesh(
      new THREE.PlaneGeometry(10, 200),
      new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    road.rotation.x = -Math.PI / 2;
    road.position.z = -50;
    road.receiveShadow = true;
    scene.add(road);

    // Trees (props)
    for (let i = -80; i <= 80; i += 20) {
      const tree = new THREE.Mesh(
        new THREE.ConeGeometry(2, 6, 8),
        new THREE.MeshStandardMaterial({ color: 0x2e8b57 })
      );
      tree.position.set(i, 3, -80);
      tree.castShadow = true;
      scene.add(tree);
    }

    // Rocks (obstacles)
    for (let i = 0; i < 5; i++) {
      const rock = new THREE.Mesh(
        new THREE.DodecahedronGeometry(1, 0),
        new THREE.MeshStandardMaterial({ color: 0x555555 })
      );
      rock.position.set(Math.random() * 40 - 20, 0.5, Math.random() * 40 - 20);
      rock.castShadow = true;
      scene.add(rock);
    }

    // ====== CHECKPOINTS (Mission) ======
    const checkpoints = [];
    const cpPositions = [
      [20, 0, -20],
      [0, 0, -50],
      [-20, 0, -80]
    ];
    let currentCP = 0;

    cpPositions.forEach(pos => {
      const cp = new THREE.Mesh(
        new THREE.RingGeometry(1.5, 2, 32),
        new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide })
      );
      cp.rotation.x = Math.PI / 2;
      cp.position.set(...pos);
      cp.userData = { active: false };
      scene.add(cp);
      checkpoints.push(cp);
    });

    // ====== CAR (Chassis + Visual + Physics) ======
    const carGroup = new THREE.Group();

    // Body
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(2, 0.6, 4),
      new THREE.MeshStandardMaterial({ color: 0x0044ff })
    );
    body.castShadow = true;
    carGroup.add(body);

    // Wheels (visual)
    const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
    wheelGeo.rotateZ(Math.PI / 2);
    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
    const wheelPos = [[-1, -0.3, -1.2], [1, -0.3, -1.2], [-1, -0.3, 1.2], [1, -0.3, 1.2]];
    wheelPos.forEach(p => {
      const w = new THREE.Mesh(wheelGeo, wheelMat);
      w.position.set(...p);
      carGroup.add(w);
    });

    scene.add(carGroup);

    // Physics body (chassis)
    const carBody = new CANNON.Body({
      mass: 200,
      shape: new CANNON.Box(new CANNON.Vec3(1, 0.3, 2)),
      position: new CANNON.Vec3(0, 1, 0)
    });
    carBody.angularDamping = 0.8;
    carBody.linearDamping = 0.1;
    world.addBody(carBody);

    // ====== INPUT ======
    const keys = {};
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    // ====== GAME STATE ======
    let speedKmh = 0;

    // ====== UPDATE LOOP ======
    const clock = new THREE.Clock();
    const fixedTimeStep = 1 / 60;

    function updateCar() {
      const force = new CANNON.Vec3(0, 0, 0);
      const torque = new CANNON.Vec3(0, 0, 0);

      // Engine force (forward/backward)
      if (keys['w']) force.z = -120;
      if (keys['s']) force.z = 80;

      // Steering torque
      if (carBody.velocity.length() > 0.1) {
        if (keys['a']) torque.y = 4;
        if (keys['d']) torque.y = -4;
      }

      // Handbrake (increase rear friction)
      if (keys[' ']) {
        carBody.angularVelocity.y *= 0.7;
        force.z *= 0.5;
      }

      // Apply in local space
      carBody.quaternion.vmult(force, force);
      carBody.quaternion.vmult(torque, torque);
      carBody.force.copy(force);
      carBody.torque.copy(torque);

      // Update speed display
      speedKmh = Math.round(carBody.velocity.length() * 3.6);
      document.getElementById('speed').textContent = speedKmh;
    }

    function checkCheckpoints() {
      const carPos = carBody.position;
      const cp = checkpoints[currentCP];
      if (!cp.userData.active) {
        const dx = carPos.x - cp.position.x;
        const dz = carPos.z - cp.position.z;
        if (Math.sqrt(dx*dx + dz*dz) < 3) {
          cp.material.color.set(0xff0000);
          cp.userData.active = true;
          currentCP++;
          if (currentCP >= checkpoints.length) {
            document.getElementById('mission').innerHTML = 'ðŸŽ‰ ALL CHECKPOINTS REACHED!<br>MISSION COMPLETE!';
          } else {
            document.getElementById('mission').textContent = `ðŸŽ¯ Next: Checkpoint ${currentCP + 1}/3`;
          }
        }
      }
    }

    // Camera follow
    function updateCamera() {
      const offset = new THREE.Vector3(0, 4, 8);
      offset.applyQuaternion(carGroup.quaternion);
      offset.add(carGroup.position);
      camera.position.lerp(offset, 0.1);
      camera.lookAt(carGroup.position);
    }

    // Render loop
    function animate() {
      requestAnimationFrame(animate);
      const delta = Math.min(clock.getDelta(), 0.1);
      world.step(fixedTimeStep, delta, 3);

      // Sync visual with physics
      carGroup.position.copy(carBody.position);
      carGroup.quaternion.copy(carBody.quaternion);

      updateCar();
      checkCheckpoints();
      updateCamera();

      renderer.render(scene, camera);
    }

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
